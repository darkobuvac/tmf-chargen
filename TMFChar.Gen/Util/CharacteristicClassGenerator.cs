using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TMFChar.Gen.Util;

public class CharacteristicClassGenerator(string @namespace, string className, List<string> fields)
{
    private readonly string _namespace = @namespace;
    private readonly string _className = className;
    private readonly List<string> _fields = fields;

    public string Build()
    {
        var namespaceDeclaration = SyntaxFactory
            .FileScopedNamespaceDeclaration(SyntaxFactory.ParseName(_namespace))
            .AddMembers(GenerateCharacteristicsClass());
        var compilationUnit = SyntaxFactory.CompilationUnit().AddMembers(namespaceDeclaration);

        return compilationUnit.NormalizeWhitespace().ToFullString();
    }

    private ClassDeclarationSyntax GenerateCharacteristicsClass()
    {
        var classDeclaration = SyntaxFactory
            .ClassDeclaration(_className)
            .AddModifiers(
                SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                SyntaxFactory.Token(SyntaxKind.PartialKeyword)
            )
            .WithLeadingTrivia(GenerateAutoGeneratedComment());

        var ctor = GenerateProtectedEmptyConstructor();
        classDeclaration = classDeclaration.AddMembers(ctor);

        foreach (var field in _fields)
        {
            var propDeclaration = GeneratePropertyDeclaration(field);
            classDeclaration = classDeclaration.AddMembers(propDeclaration);
        }

        var getMehod = GenerateGetMethod();
        classDeclaration = classDeclaration.AddMembers(getMehod);

        return classDeclaration;
    }

    private static PropertyDeclarationSyntax GeneratePropertyDeclaration(string name)
    {
        var propName = SyntaxFactory.Identifier(ConvertToPascalCase(name));
        var propDeclaration = SyntaxFactory
            .PropertyDeclaration(SyntaxFactory.ParseTypeName("string"), propName)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            .WithExpressionBody(
                SyntaxFactory.ArrowExpressionClause(
                    SyntaxFactory.LiteralExpression(
                        SyntaxKind.StringLiteralExpression,
                        SyntaxFactory.Literal(name)
                    )
                )
            )
            .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));

        return propDeclaration;
    }

    private ConstructorDeclarationSyntax GenerateProtectedEmptyConstructor()
    {
        return SyntaxFactory
            .ConstructorDeclaration(_className)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.ProtectedKeyword))
            .WithBody(SyntaxFactory.Block());
    }

    private static SyntaxTriviaList GenerateAutoGeneratedComment()
    {
        var list = SyntaxFactory.TriviaList();
        list = list.Add(SyntaxFactory.Comment("// <autogenerated>"));
        list = list.Add(SyntaxFactory.Comment("//     This code was generated by a tool."));
        list = list.Add(
            SyntaxFactory.Comment(
                "//     Changes to this file may cause incorrect behavior and will be lost if"
            )
        );
        list = list.Add(SyntaxFactory.Comment("//     the code is regenerated."));
        list = list.Add(SyntaxFactory.Comment("// </autogenerated>"));
        return list;
    }

    private MethodDeclarationSyntax GenerateGetMethod()
    {
        return SyntaxFactory
            .MethodDeclaration(SyntaxFactory.ParseTypeName("string"), "Get")
            .AddModifiers(
                SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                SyntaxFactory.Token(SyntaxKind.StaticKeyword)
            )
            .AddParameterListParameters(
                SyntaxFactory
                    .Parameter(SyntaxFactory.Identifier("picker"))
                    .WithType(SyntaxFactory.ParseTypeName($"Func<{_className}, string>"))
            )
            .WithBody(
                SyntaxFactory.Block(
                    SyntaxFactory.ReturnStatement(
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.IdentifierName("picker"),
                            SyntaxFactory.ArgumentList(
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.Argument(
                                        SyntaxFactory
                                            .ObjectCreationExpression(
                                                SyntaxFactory.IdentifierName($"{_className}")
                                            )
                                            .WithArgumentList(SyntaxFactory.ArgumentList())
                                    )
                                )
                            )
                        )
                    )
                )
            );
    }

    private static FieldDeclarationSyntax GenerateFieldDeclaration(string name)
    {
        var fieldName = ConvertToPascalCase(name);

        var fieldDeclaration = SyntaxFactory
            .FieldDeclaration(
                SyntaxFactory
                    .VariableDeclaration(SyntaxFactory.ParseTypeName("string"))
                    .AddVariables(
                        SyntaxFactory
                            .VariableDeclarator(fieldName)
                            .WithInitializer(
                                SyntaxFactory.EqualsValueClause(
                                    SyntaxFactory.LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        SyntaxFactory.Literal(name)
                                    )
                                )
                            )
                    )
            )
            .AddModifiers(
                SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                SyntaxFactory.Token(SyntaxKind.ConstKeyword)
            );

        return fieldDeclaration;
    }

    private static string ConvertToPascalCase(string input)
    {
        var words = input.Split(['_', '-', ' '], StringSplitOptions.RemoveEmptyEntries);
        var result = new StringBuilder();

        foreach (var word in words)
        {
            result.Append(char.ToUpper(word[0])).Append(word[1..]);
        }

        return result.ToString();
    }
}
